// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:8866"
var Secret = ""

func (client *Client) Message(params MessageWhereUniqueInput) *MessageExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"MessageWhereUniqueInput!", "Message"},
		"message",
		[]string{"id", "user", "roomid", "content"})

	return &MessageExec{ret}
}

type MessagesParams struct {
	Where   *MessageWhereInput   `json:"where,omitempty"`
	OrderBy *MessageOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Messages(params *MessagesParams) *MessageExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"MessageWhereInput", "MessageOrderByInput", "Message"},
		"messages",
		[]string{"id", "user", "roomid", "content"})

	return &MessageExecArray{ret}
}

type MessagesConnectionParams struct {
	Where   *MessageWhereInput   `json:"where,omitempty"`
	OrderBy *MessageOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *MessageConnection) Nodes() []Message {
	var nodes []Message
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *MessageConnection) NodesPtr() []*Message {
	var nodes []*Message
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) MessagesConnection(params *MessagesConnectionParams) *MessageConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"MessageWhereInput", "MessageOrderByInput", "Message"},
		"messagesConnection",
		[]string{"edges", "pageInfo"})

	return &MessageConnectionExec{ret}
}

func (client *Client) Room(params RoomWhereUniqueInput) *RoomExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"RoomWhereUniqueInput!", "Room"},
		"room",
		[]string{"id", "name", "roomid", "createday"})

	return &RoomExec{ret}
}

type RoomsParams struct {
	Where   *RoomWhereInput   `json:"where,omitempty"`
	OrderBy *RoomOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Rooms(params *RoomsParams) *RoomExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RoomWhereInput", "RoomOrderByInput", "Room"},
		"rooms",
		[]string{"id", "name", "roomid", "createday"})

	return &RoomExecArray{ret}
}

type RoomsConnectionParams struct {
	Where   *RoomWhereInput   `json:"where,omitempty"`
	OrderBy *RoomOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *RoomConnection) Nodes() []Room {
	var nodes []Room
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *RoomConnection) NodesPtr() []*Room {
	var nodes []*Room
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) RoomsConnection(params *RoomsConnectionParams) *RoomConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RoomWhereInput", "RoomOrderByInput", "Room"},
		"roomsConnection",
		[]string{"edges", "pageInfo"})

	return &RoomConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "userName", "alias", "passWord", "email", "ava"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "userName", "alias", "passWord", "email", "ava"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *UserConnection) Nodes() []User {
	var nodes []User
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *UserConnection) NodesPtr() []*User {
	var nodes []*User
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) CreateMessage(params MessageCreateInput) *MessageExec {
	ret := client.Client.Create(
		params,
		[2]string{"MessageCreateInput!", "Message"},
		"createMessage",
		[]string{"id", "user", "roomid", "content"})

	return &MessageExec{ret}
}

type MessageUpdateParams struct {
	Data  MessageUpdateInput      `json:"data"`
	Where MessageWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateMessage(params MessageUpdateParams) *MessageExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"MessageUpdateInput!", "MessageWhereUniqueInput!", "Message"},
		"updateMessage",
		[]string{"id", "user", "roomid", "content"})

	return &MessageExec{ret}
}

type MessageUpdateManyParams struct {
	Data  MessageUpdateManyMutationInput `json:"data"`
	Where *MessageWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyMessages(params MessageUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"MessageUpdateManyMutationInput!", "MessageWhereInput"},
		"updateManyMessages")
	return &BatchPayloadExec{exec}
}

type MessageUpsertParams struct {
	Where  MessageWhereUniqueInput `json:"where"`
	Create MessageCreateInput      `json:"create"`
	Update MessageUpdateInput      `json:"update"`
}

func (client *Client) UpsertMessage(params MessageUpsertParams) *MessageExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"MessageWhereUniqueInput!", "MessageCreateInput!", "MessageUpdateInput!", "Message"},
		"upsertMessage",
		[]string{"id", "user", "roomid", "content"})

	return &MessageExec{ret}
}

func (client *Client) DeleteMessage(params MessageWhereUniqueInput) *MessageExec {
	ret := client.Client.Delete(
		params,
		[2]string{"MessageWhereUniqueInput!", "Message"},
		"deleteMessage",
		[]string{"id", "user", "roomid", "content"})

	return &MessageExec{ret}
}

func (client *Client) DeleteManyMessages(params *MessageWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "MessageWhereInput", "deleteManyMessages")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateRoom(params RoomCreateInput) *RoomExec {
	ret := client.Client.Create(
		params,
		[2]string{"RoomCreateInput!", "Room"},
		"createRoom",
		[]string{"id", "name", "roomid", "createday"})

	return &RoomExec{ret}
}

type RoomUpdateParams struct {
	Data  RoomUpdateInput      `json:"data"`
	Where RoomWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateRoom(params RoomUpdateParams) *RoomExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"RoomUpdateInput!", "RoomWhereUniqueInput!", "Room"},
		"updateRoom",
		[]string{"id", "name", "roomid", "createday"})

	return &RoomExec{ret}
}

type RoomUpdateManyParams struct {
	Data  RoomUpdateManyMutationInput `json:"data"`
	Where *RoomWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyRooms(params RoomUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"RoomUpdateManyMutationInput!", "RoomWhereInput"},
		"updateManyRooms")
	return &BatchPayloadExec{exec}
}

type RoomUpsertParams struct {
	Where  RoomWhereUniqueInput `json:"where"`
	Create RoomCreateInput      `json:"create"`
	Update RoomUpdateInput      `json:"update"`
}

func (client *Client) UpsertRoom(params RoomUpsertParams) *RoomExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"RoomWhereUniqueInput!", "RoomCreateInput!", "RoomUpdateInput!", "Room"},
		"upsertRoom",
		[]string{"id", "name", "roomid", "createday"})

	return &RoomExec{ret}
}

func (client *Client) DeleteRoom(params RoomWhereUniqueInput) *RoomExec {
	ret := client.Client.Delete(
		params,
		[2]string{"RoomWhereUniqueInput!", "Room"},
		"deleteRoom",
		[]string{"id", "name", "roomid", "createday"})

	return &RoomExec{ret}
}

func (client *Client) DeleteManyRooms(params *RoomWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "RoomWhereInput", "deleteManyRooms")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "userName", "alias", "passWord", "email", "ava"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "userName", "alias", "passWord", "email", "ava"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "userName", "alias", "passWord", "email", "ava"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "userName", "alias", "passWord", "email", "ava"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type MessageOrderByInput string

const (
	MessageOrderByInputIDAsc       MessageOrderByInput = "id_ASC"
	MessageOrderByInputIDDesc      MessageOrderByInput = "id_DESC"
	MessageOrderByInputUserAsc     MessageOrderByInput = "user_ASC"
	MessageOrderByInputUserDesc    MessageOrderByInput = "user_DESC"
	MessageOrderByInputRoomidAsc   MessageOrderByInput = "roomid_ASC"
	MessageOrderByInputRoomidDesc  MessageOrderByInput = "roomid_DESC"
	MessageOrderByInputContentAsc  MessageOrderByInput = "content_ASC"
	MessageOrderByInputContentDesc MessageOrderByInput = "content_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc        UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc       UserOrderByInput = "id_DESC"
	UserOrderByInputUserNameAsc  UserOrderByInput = "userName_ASC"
	UserOrderByInputUserNameDesc UserOrderByInput = "userName_DESC"
	UserOrderByInputAliasAsc     UserOrderByInput = "alias_ASC"
	UserOrderByInputAliasDesc    UserOrderByInput = "alias_DESC"
	UserOrderByInputPassWordAsc  UserOrderByInput = "passWord_ASC"
	UserOrderByInputPassWordDesc UserOrderByInput = "passWord_DESC"
	UserOrderByInputEmailAsc     UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc    UserOrderByInput = "email_DESC"
	UserOrderByInputAvaAsc       UserOrderByInput = "ava_ASC"
	UserOrderByInputAvaDesc      UserOrderByInput = "ava_DESC"
)

type RoomOrderByInput string

const (
	RoomOrderByInputIDAsc         RoomOrderByInput = "id_ASC"
	RoomOrderByInputIDDesc        RoomOrderByInput = "id_DESC"
	RoomOrderByInputNameAsc       RoomOrderByInput = "name_ASC"
	RoomOrderByInputNameDesc      RoomOrderByInput = "name_DESC"
	RoomOrderByInputRoomidAsc     RoomOrderByInput = "roomid_ASC"
	RoomOrderByInputRoomidDesc    RoomOrderByInput = "roomid_DESC"
	RoomOrderByInputCreatedayAsc  RoomOrderByInput = "createday_ASC"
	RoomOrderByInputCreatedayDesc RoomOrderByInput = "createday_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type MessageCreateInput struct {
	ID      *string `json:"id,omitempty"`
	User    string  `json:"user"`
	Roomid  string  `json:"roomid"`
	Content string  `json:"content"`
}

type MessageWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserScalarWhereInput struct {
	ID                    *string                `json:"id,omitempty"`
	IDNot                 *string                `json:"id_not,omitempty"`
	IDIn                  []string               `json:"id_in,omitempty"`
	IDNotIn               []string               `json:"id_not_in,omitempty"`
	IDLt                  *string                `json:"id_lt,omitempty"`
	IDLte                 *string                `json:"id_lte,omitempty"`
	IDGt                  *string                `json:"id_gt,omitempty"`
	IDGte                 *string                `json:"id_gte,omitempty"`
	IDContains            *string                `json:"id_contains,omitempty"`
	IDNotContains         *string                `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                `json:"id_not_ends_with,omitempty"`
	UserName              *string                `json:"userName,omitempty"`
	UserNameNot           *string                `json:"userName_not,omitempty"`
	UserNameIn            []string               `json:"userName_in,omitempty"`
	UserNameNotIn         []string               `json:"userName_not_in,omitempty"`
	UserNameLt            *string                `json:"userName_lt,omitempty"`
	UserNameLte           *string                `json:"userName_lte,omitempty"`
	UserNameGt            *string                `json:"userName_gt,omitempty"`
	UserNameGte           *string                `json:"userName_gte,omitempty"`
	UserNameContains      *string                `json:"userName_contains,omitempty"`
	UserNameNotContains   *string                `json:"userName_not_contains,omitempty"`
	UserNameStartsWith    *string                `json:"userName_starts_with,omitempty"`
	UserNameNotStartsWith *string                `json:"userName_not_starts_with,omitempty"`
	UserNameEndsWith      *string                `json:"userName_ends_with,omitempty"`
	UserNameNotEndsWith   *string                `json:"userName_not_ends_with,omitempty"`
	Alias                 *string                `json:"alias,omitempty"`
	AliasNot              *string                `json:"alias_not,omitempty"`
	AliasIn               []string               `json:"alias_in,omitempty"`
	AliasNotIn            []string               `json:"alias_not_in,omitempty"`
	AliasLt               *string                `json:"alias_lt,omitempty"`
	AliasLte              *string                `json:"alias_lte,omitempty"`
	AliasGt               *string                `json:"alias_gt,omitempty"`
	AliasGte              *string                `json:"alias_gte,omitempty"`
	AliasContains         *string                `json:"alias_contains,omitempty"`
	AliasNotContains      *string                `json:"alias_not_contains,omitempty"`
	AliasStartsWith       *string                `json:"alias_starts_with,omitempty"`
	AliasNotStartsWith    *string                `json:"alias_not_starts_with,omitempty"`
	AliasEndsWith         *string                `json:"alias_ends_with,omitempty"`
	AliasNotEndsWith      *string                `json:"alias_not_ends_with,omitempty"`
	PassWord              *string                `json:"passWord,omitempty"`
	PassWordNot           *string                `json:"passWord_not,omitempty"`
	PassWordIn            []string               `json:"passWord_in,omitempty"`
	PassWordNotIn         []string               `json:"passWord_not_in,omitempty"`
	PassWordLt            *string                `json:"passWord_lt,omitempty"`
	PassWordLte           *string                `json:"passWord_lte,omitempty"`
	PassWordGt            *string                `json:"passWord_gt,omitempty"`
	PassWordGte           *string                `json:"passWord_gte,omitempty"`
	PassWordContains      *string                `json:"passWord_contains,omitempty"`
	PassWordNotContains   *string                `json:"passWord_not_contains,omitempty"`
	PassWordStartsWith    *string                `json:"passWord_starts_with,omitempty"`
	PassWordNotStartsWith *string                `json:"passWord_not_starts_with,omitempty"`
	PassWordEndsWith      *string                `json:"passWord_ends_with,omitempty"`
	PassWordNotEndsWith   *string                `json:"passWord_not_ends_with,omitempty"`
	Email                 *string                `json:"email,omitempty"`
	EmailNot              *string                `json:"email_not,omitempty"`
	EmailIn               []string               `json:"email_in,omitempty"`
	EmailNotIn            []string               `json:"email_not_in,omitempty"`
	EmailLt               *string                `json:"email_lt,omitempty"`
	EmailLte              *string                `json:"email_lte,omitempty"`
	EmailGt               *string                `json:"email_gt,omitempty"`
	EmailGte              *string                `json:"email_gte,omitempty"`
	EmailContains         *string                `json:"email_contains,omitempty"`
	EmailNotContains      *string                `json:"email_not_contains,omitempty"`
	EmailStartsWith       *string                `json:"email_starts_with,omitempty"`
	EmailNotStartsWith    *string                `json:"email_not_starts_with,omitempty"`
	EmailEndsWith         *string                `json:"email_ends_with,omitempty"`
	EmailNotEndsWith      *string                `json:"email_not_ends_with,omitempty"`
	Ava                   *string                `json:"ava,omitempty"`
	AvaNot                *string                `json:"ava_not,omitempty"`
	AvaIn                 []string               `json:"ava_in,omitempty"`
	AvaNotIn              []string               `json:"ava_not_in,omitempty"`
	AvaLt                 *string                `json:"ava_lt,omitempty"`
	AvaLte                *string                `json:"ava_lte,omitempty"`
	AvaGt                 *string                `json:"ava_gt,omitempty"`
	AvaGte                *string                `json:"ava_gte,omitempty"`
	AvaContains           *string                `json:"ava_contains,omitempty"`
	AvaNotContains        *string                `json:"ava_not_contains,omitempty"`
	AvaStartsWith         *string                `json:"ava_starts_with,omitempty"`
	AvaNotStartsWith      *string                `json:"ava_not_starts_with,omitempty"`
	AvaEndsWith           *string                `json:"ava_ends_with,omitempty"`
	AvaNotEndsWith        *string                `json:"ava_not_ends_with,omitempty"`
	And                   []UserScalarWhereInput `json:"AND,omitempty"`
	Or                    []UserScalarWhereInput `json:"OR,omitempty"`
	Not                   []UserScalarWhereInput `json:"NOT,omitempty"`
}

type RoomCreateInput struct {
	ID        *string              `json:"id,omitempty"`
	Name      string               `json:"name"`
	Roomid    string               `json:"roomid"`
	Users     *UserCreateManyInput `json:"users,omitempty"`
	Createday string               `json:"createday"`
}

type UserUpsertWithWhereUniqueNestedInput struct {
	Where  UserWhereUniqueInput `json:"where"`
	Update UserUpdateDataInput  `json:"update"`
	Create UserCreateInput      `json:"create"`
}

type RoomSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *RoomWhereInput              `json:"node,omitempty"`
	And                        []RoomSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []RoomSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []RoomSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserUpdateDataInput struct {
	UserName *string `json:"userName,omitempty"`
	Alias    *string `json:"alias,omitempty"`
	PassWord *string `json:"passWord,omitempty"`
	Email    *string `json:"email,omitempty"`
	Ava      *string `json:"ava,omitempty"`
}

type UserUpdateManyMutationInput struct {
	UserName *string `json:"userName,omitempty"`
	Alias    *string `json:"alias,omitempty"`
	PassWord *string `json:"passWord,omitempty"`
	Email    *string `json:"email,omitempty"`
	Ava      *string `json:"ava,omitempty"`
}

type UserWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	UserName *string `json:"userName,omitempty"`
}

type UserUpdateInput struct {
	UserName *string `json:"userName,omitempty"`
	Alias    *string `json:"alias,omitempty"`
	PassWord *string `json:"passWord,omitempty"`
	Email    *string `json:"email,omitempty"`
	Ava      *string `json:"ava,omitempty"`
}

type UserUpdateWithWhereUniqueNestedInput struct {
	Where UserWhereUniqueInput `json:"where"`
	Data  UserUpdateDataInput  `json:"data"`
}

type MessageWhereInput struct {
	ID                   *string             `json:"id,omitempty"`
	IDNot                *string             `json:"id_not,omitempty"`
	IDIn                 []string            `json:"id_in,omitempty"`
	IDNotIn              []string            `json:"id_not_in,omitempty"`
	IDLt                 *string             `json:"id_lt,omitempty"`
	IDLte                *string             `json:"id_lte,omitempty"`
	IDGt                 *string             `json:"id_gt,omitempty"`
	IDGte                *string             `json:"id_gte,omitempty"`
	IDContains           *string             `json:"id_contains,omitempty"`
	IDNotContains        *string             `json:"id_not_contains,omitempty"`
	IDStartsWith         *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string             `json:"id_not_ends_with,omitempty"`
	User                 *string             `json:"user,omitempty"`
	UserNot              *string             `json:"user_not,omitempty"`
	UserIn               []string            `json:"user_in,omitempty"`
	UserNotIn            []string            `json:"user_not_in,omitempty"`
	UserLt               *string             `json:"user_lt,omitempty"`
	UserLte              *string             `json:"user_lte,omitempty"`
	UserGt               *string             `json:"user_gt,omitempty"`
	UserGte              *string             `json:"user_gte,omitempty"`
	UserContains         *string             `json:"user_contains,omitempty"`
	UserNotContains      *string             `json:"user_not_contains,omitempty"`
	UserStartsWith       *string             `json:"user_starts_with,omitempty"`
	UserNotStartsWith    *string             `json:"user_not_starts_with,omitempty"`
	UserEndsWith         *string             `json:"user_ends_with,omitempty"`
	UserNotEndsWith      *string             `json:"user_not_ends_with,omitempty"`
	Roomid               *string             `json:"roomid,omitempty"`
	RoomidNot            *string             `json:"roomid_not,omitempty"`
	RoomidIn             []string            `json:"roomid_in,omitempty"`
	RoomidNotIn          []string            `json:"roomid_not_in,omitempty"`
	RoomidLt             *string             `json:"roomid_lt,omitempty"`
	RoomidLte            *string             `json:"roomid_lte,omitempty"`
	RoomidGt             *string             `json:"roomid_gt,omitempty"`
	RoomidGte            *string             `json:"roomid_gte,omitempty"`
	RoomidContains       *string             `json:"roomid_contains,omitempty"`
	RoomidNotContains    *string             `json:"roomid_not_contains,omitempty"`
	RoomidStartsWith     *string             `json:"roomid_starts_with,omitempty"`
	RoomidNotStartsWith  *string             `json:"roomid_not_starts_with,omitempty"`
	RoomidEndsWith       *string             `json:"roomid_ends_with,omitempty"`
	RoomidNotEndsWith    *string             `json:"roomid_not_ends_with,omitempty"`
	Content              *string             `json:"content,omitempty"`
	ContentNot           *string             `json:"content_not,omitempty"`
	ContentIn            []string            `json:"content_in,omitempty"`
	ContentNotIn         []string            `json:"content_not_in,omitempty"`
	ContentLt            *string             `json:"content_lt,omitempty"`
	ContentLte           *string             `json:"content_lte,omitempty"`
	ContentGt            *string             `json:"content_gt,omitempty"`
	ContentGte           *string             `json:"content_gte,omitempty"`
	ContentContains      *string             `json:"content_contains,omitempty"`
	ContentNotContains   *string             `json:"content_not_contains,omitempty"`
	ContentStartsWith    *string             `json:"content_starts_with,omitempty"`
	ContentNotStartsWith *string             `json:"content_not_starts_with,omitempty"`
	ContentEndsWith      *string             `json:"content_ends_with,omitempty"`
	ContentNotEndsWith   *string             `json:"content_not_ends_with,omitempty"`
	And                  []MessageWhereInput `json:"AND,omitempty"`
	Or                   []MessageWhereInput `json:"OR,omitempty"`
	Not                  []MessageWhereInput `json:"NOT,omitempty"`
}

type UserUpdateManyInput struct {
	Create     []UserCreateInput                      `json:"create,omitempty"`
	Update     []UserUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []UserWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []UserScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type UserUpdateManyDataInput struct {
	UserName *string `json:"userName,omitempty"`
	Alias    *string `json:"alias,omitempty"`
	PassWord *string `json:"passWord,omitempty"`
	Email    *string `json:"email,omitempty"`
	Ava      *string `json:"ava,omitempty"`
}

type RoomUpdateInput struct {
	Name      *string              `json:"name,omitempty"`
	Roomid    *string              `json:"roomid,omitempty"`
	Users     *UserUpdateManyInput `json:"users,omitempty"`
	Createday *string              `json:"createday,omitempty"`
}

type UserUpdateManyWithWhereNestedInput struct {
	Where UserScalarWhereInput    `json:"where"`
	Data  UserUpdateManyDataInput `json:"data"`
}

type UserCreateManyInput struct {
	Create  []UserCreateInput      `json:"create,omitempty"`
	Connect []UserWhereUniqueInput `json:"connect,omitempty"`
}

type MessageUpdateManyMutationInput struct {
	User    *string `json:"user,omitempty"`
	Roomid  *string `json:"roomid,omitempty"`
	Content *string `json:"content,omitempty"`
}

type MessageUpdateInput struct {
	User    *string `json:"user,omitempty"`
	Roomid  *string `json:"roomid,omitempty"`
	Content *string `json:"content,omitempty"`
}

type UserCreateInput struct {
	ID       *string `json:"id,omitempty"`
	UserName string  `json:"userName"`
	Alias    string  `json:"alias"`
	PassWord string  `json:"passWord"`
	Email    string  `json:"email"`
	Ava      string  `json:"ava"`
}

type RoomWhereUniqueInput struct {
	ID     *string `json:"id,omitempty"`
	Roomid *string `json:"roomid,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type RoomWhereInput struct {
	ID                  *string          `json:"id,omitempty"`
	IDNot               *string          `json:"id_not,omitempty"`
	IDIn                []string         `json:"id_in,omitempty"`
	IDNotIn             []string         `json:"id_not_in,omitempty"`
	IDLt                *string          `json:"id_lt,omitempty"`
	IDLte               *string          `json:"id_lte,omitempty"`
	IDGt                *string          `json:"id_gt,omitempty"`
	IDGte               *string          `json:"id_gte,omitempty"`
	IDContains          *string          `json:"id_contains,omitempty"`
	IDNotContains       *string          `json:"id_not_contains,omitempty"`
	IDStartsWith        *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string          `json:"id_not_ends_with,omitempty"`
	Name                *string          `json:"name,omitempty"`
	NameNot             *string          `json:"name_not,omitempty"`
	NameIn              []string         `json:"name_in,omitempty"`
	NameNotIn           []string         `json:"name_not_in,omitempty"`
	NameLt              *string          `json:"name_lt,omitempty"`
	NameLte             *string          `json:"name_lte,omitempty"`
	NameGt              *string          `json:"name_gt,omitempty"`
	NameGte             *string          `json:"name_gte,omitempty"`
	NameContains        *string          `json:"name_contains,omitempty"`
	NameNotContains     *string          `json:"name_not_contains,omitempty"`
	NameStartsWith      *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith   *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith        *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith     *string          `json:"name_not_ends_with,omitempty"`
	Roomid              *string          `json:"roomid,omitempty"`
	RoomidNot           *string          `json:"roomid_not,omitempty"`
	RoomidIn            []string         `json:"roomid_in,omitempty"`
	RoomidNotIn         []string         `json:"roomid_not_in,omitempty"`
	RoomidLt            *string          `json:"roomid_lt,omitempty"`
	RoomidLte           *string          `json:"roomid_lte,omitempty"`
	RoomidGt            *string          `json:"roomid_gt,omitempty"`
	RoomidGte           *string          `json:"roomid_gte,omitempty"`
	RoomidContains      *string          `json:"roomid_contains,omitempty"`
	RoomidNotContains   *string          `json:"roomid_not_contains,omitempty"`
	RoomidStartsWith    *string          `json:"roomid_starts_with,omitempty"`
	RoomidNotStartsWith *string          `json:"roomid_not_starts_with,omitempty"`
	RoomidEndsWith      *string          `json:"roomid_ends_with,omitempty"`
	RoomidNotEndsWith   *string          `json:"roomid_not_ends_with,omitempty"`
	UsersEvery          *UserWhereInput  `json:"users_every,omitempty"`
	UsersSome           *UserWhereInput  `json:"users_some,omitempty"`
	UsersNone           *UserWhereInput  `json:"users_none,omitempty"`
	Createday           *string          `json:"createday,omitempty"`
	CreatedayNot        *string          `json:"createday_not,omitempty"`
	CreatedayIn         []string         `json:"createday_in,omitempty"`
	CreatedayNotIn      []string         `json:"createday_not_in,omitempty"`
	CreatedayLt         *string          `json:"createday_lt,omitempty"`
	CreatedayLte        *string          `json:"createday_lte,omitempty"`
	CreatedayGt         *string          `json:"createday_gt,omitempty"`
	CreatedayGte        *string          `json:"createday_gte,omitempty"`
	And                 []RoomWhereInput `json:"AND,omitempty"`
	Or                  []RoomWhereInput `json:"OR,omitempty"`
	Not                 []RoomWhereInput `json:"NOT,omitempty"`
}

type RoomUpdateManyMutationInput struct {
	Name      *string `json:"name,omitempty"`
	Roomid    *string `json:"roomid,omitempty"`
	Createday *string `json:"createday,omitempty"`
}

type UserWhereInput struct {
	ID                    *string          `json:"id,omitempty"`
	IDNot                 *string          `json:"id_not,omitempty"`
	IDIn                  []string         `json:"id_in,omitempty"`
	IDNotIn               []string         `json:"id_not_in,omitempty"`
	IDLt                  *string          `json:"id_lt,omitempty"`
	IDLte                 *string          `json:"id_lte,omitempty"`
	IDGt                  *string          `json:"id_gt,omitempty"`
	IDGte                 *string          `json:"id_gte,omitempty"`
	IDContains            *string          `json:"id_contains,omitempty"`
	IDNotContains         *string          `json:"id_not_contains,omitempty"`
	IDStartsWith          *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string          `json:"id_not_ends_with,omitempty"`
	UserName              *string          `json:"userName,omitempty"`
	UserNameNot           *string          `json:"userName_not,omitempty"`
	UserNameIn            []string         `json:"userName_in,omitempty"`
	UserNameNotIn         []string         `json:"userName_not_in,omitempty"`
	UserNameLt            *string          `json:"userName_lt,omitempty"`
	UserNameLte           *string          `json:"userName_lte,omitempty"`
	UserNameGt            *string          `json:"userName_gt,omitempty"`
	UserNameGte           *string          `json:"userName_gte,omitempty"`
	UserNameContains      *string          `json:"userName_contains,omitempty"`
	UserNameNotContains   *string          `json:"userName_not_contains,omitempty"`
	UserNameStartsWith    *string          `json:"userName_starts_with,omitempty"`
	UserNameNotStartsWith *string          `json:"userName_not_starts_with,omitempty"`
	UserNameEndsWith      *string          `json:"userName_ends_with,omitempty"`
	UserNameNotEndsWith   *string          `json:"userName_not_ends_with,omitempty"`
	Alias                 *string          `json:"alias,omitempty"`
	AliasNot              *string          `json:"alias_not,omitempty"`
	AliasIn               []string         `json:"alias_in,omitempty"`
	AliasNotIn            []string         `json:"alias_not_in,omitempty"`
	AliasLt               *string          `json:"alias_lt,omitempty"`
	AliasLte              *string          `json:"alias_lte,omitempty"`
	AliasGt               *string          `json:"alias_gt,omitempty"`
	AliasGte              *string          `json:"alias_gte,omitempty"`
	AliasContains         *string          `json:"alias_contains,omitempty"`
	AliasNotContains      *string          `json:"alias_not_contains,omitempty"`
	AliasStartsWith       *string          `json:"alias_starts_with,omitempty"`
	AliasNotStartsWith    *string          `json:"alias_not_starts_with,omitempty"`
	AliasEndsWith         *string          `json:"alias_ends_with,omitempty"`
	AliasNotEndsWith      *string          `json:"alias_not_ends_with,omitempty"`
	PassWord              *string          `json:"passWord,omitempty"`
	PassWordNot           *string          `json:"passWord_not,omitempty"`
	PassWordIn            []string         `json:"passWord_in,omitempty"`
	PassWordNotIn         []string         `json:"passWord_not_in,omitempty"`
	PassWordLt            *string          `json:"passWord_lt,omitempty"`
	PassWordLte           *string          `json:"passWord_lte,omitempty"`
	PassWordGt            *string          `json:"passWord_gt,omitempty"`
	PassWordGte           *string          `json:"passWord_gte,omitempty"`
	PassWordContains      *string          `json:"passWord_contains,omitempty"`
	PassWordNotContains   *string          `json:"passWord_not_contains,omitempty"`
	PassWordStartsWith    *string          `json:"passWord_starts_with,omitempty"`
	PassWordNotStartsWith *string          `json:"passWord_not_starts_with,omitempty"`
	PassWordEndsWith      *string          `json:"passWord_ends_with,omitempty"`
	PassWordNotEndsWith   *string          `json:"passWord_not_ends_with,omitempty"`
	Email                 *string          `json:"email,omitempty"`
	EmailNot              *string          `json:"email_not,omitempty"`
	EmailIn               []string         `json:"email_in,omitempty"`
	EmailNotIn            []string         `json:"email_not_in,omitempty"`
	EmailLt               *string          `json:"email_lt,omitempty"`
	EmailLte              *string          `json:"email_lte,omitempty"`
	EmailGt               *string          `json:"email_gt,omitempty"`
	EmailGte              *string          `json:"email_gte,omitempty"`
	EmailContains         *string          `json:"email_contains,omitempty"`
	EmailNotContains      *string          `json:"email_not_contains,omitempty"`
	EmailStartsWith       *string          `json:"email_starts_with,omitempty"`
	EmailNotStartsWith    *string          `json:"email_not_starts_with,omitempty"`
	EmailEndsWith         *string          `json:"email_ends_with,omitempty"`
	EmailNotEndsWith      *string          `json:"email_not_ends_with,omitempty"`
	Ava                   *string          `json:"ava,omitempty"`
	AvaNot                *string          `json:"ava_not,omitempty"`
	AvaIn                 []string         `json:"ava_in,omitempty"`
	AvaNotIn              []string         `json:"ava_not_in,omitempty"`
	AvaLt                 *string          `json:"ava_lt,omitempty"`
	AvaLte                *string          `json:"ava_lte,omitempty"`
	AvaGt                 *string          `json:"ava_gt,omitempty"`
	AvaGte                *string          `json:"ava_gte,omitempty"`
	AvaContains           *string          `json:"ava_contains,omitempty"`
	AvaNotContains        *string          `json:"ava_not_contains,omitempty"`
	AvaStartsWith         *string          `json:"ava_starts_with,omitempty"`
	AvaNotStartsWith      *string          `json:"ava_not_starts_with,omitempty"`
	AvaEndsWith           *string          `json:"ava_ends_with,omitempty"`
	AvaNotEndsWith        *string          `json:"ava_not_ends_with,omitempty"`
	And                   []UserWhereInput `json:"AND,omitempty"`
	Or                    []UserWhereInput `json:"OR,omitempty"`
	Not                   []UserWhereInput `json:"NOT,omitempty"`
}

type MessageSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *MessageWhereInput              `json:"node,omitempty"`
	And                        []MessageSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []MessageSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []MessageSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserPreviousValuesFields = []string{"id", "userName", "alias", "passWord", "email", "ava"}

type UserPreviousValues struct {
	ID       string `json:"id"`
	UserName string `json:"userName"`
	Alias    string `json:"alias"`
	PassWord string `json:"passWord"`
	Email    string `json:"email"`
	Ava      string `json:"ava"`
}

type RoomPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance RoomPreviousValuesExec) Exec(ctx context.Context) (*RoomPreviousValues, error) {
	var v RoomPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RoomPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RoomPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance RoomPreviousValuesExecArray) Exec(ctx context.Context) ([]RoomPreviousValues, error) {
	var v []RoomPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RoomPreviousValuesFields = []string{"id", "name", "roomid", "createday"}

type RoomPreviousValues struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Roomid    string `json:"roomid"`
	Createday string `json:"createday"`
}

type RoomSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *RoomSubscriptionPayloadExec) Node() *RoomExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Room"},
		"node",
		[]string{"id", "name", "roomid", "createday"})

	return &RoomExec{ret}
}

func (instance *RoomSubscriptionPayloadExec) PreviousValues() *RoomPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RoomPreviousValues"},
		"previousValues",
		[]string{"id", "name", "roomid", "createday"})

	return &RoomPreviousValuesExec{ret}
}

func (instance RoomSubscriptionPayloadExec) Exec(ctx context.Context) (*RoomSubscriptionPayload, error) {
	var v RoomSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RoomSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RoomSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance RoomSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RoomSubscriptionPayload, error) {
	var v []RoomSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RoomSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type RoomSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Room        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserExec struct {
	exec *prisma.Exec
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserFields = []string{"id", "userName", "alias", "passWord", "email", "ava"}

type User struct {
	ID       string `json:"id"`
	UserName string `json:"userName"`
	Alias    string `json:"alias"`
	PassWord string `json:"passWord"`
	Email    string `json:"email"`
	Ava      string `json:"ava"`
}

type RoomExec struct {
	exec *prisma.Exec
}

type UsersParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *RoomExec) Users(params *UsersParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "userName", "alias", "passWord", "email", "ava"})

	return &UserExecArray{ret}
}

func (instance RoomExec) Exec(ctx context.Context) (*Room, error) {
	var v Room
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RoomExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RoomExecArray struct {
	exec *prisma.Exec
}

func (instance RoomExecArray) Exec(ctx context.Context) ([]Room, error) {
	var v []Room
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RoomFields = []string{"id", "name", "roomid", "createday"}

type Room struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Roomid    string `json:"roomid"`
	Createday string `json:"createday"`
}

type MessageConnectionExec struct {
	exec *prisma.Exec
}

func (instance *MessageConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *MessageConnectionExec) Edges() *MessageEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"MessageWhereInput", "MessageOrderByInput", "MessageEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Message"},
		"node",
		MessageFields)

	return &MessageEdgeExecArray{nodes}
}

func (instance *MessageConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateMessage"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance MessageConnectionExec) Exec(ctx context.Context) (*MessageConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &MessageConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance MessageConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MessageConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance MessageConnectionExecArray) Exec(ctx context.Context) ([]MessageConnection, error) {
	var v []MessageConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MessageConnectionFields = []string{}

type MessageConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []MessageEdge `json:"edges"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "User"},
		"node",
		UserFields)

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserConnectionFields = []string{}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type RoomEdgeExec struct {
	exec *prisma.Exec
}

func (instance *RoomEdgeExec) Node() *RoomExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Room"},
		"node",
		[]string{"id", "name", "roomid", "createday"})

	return &RoomExec{ret}
}

func (instance RoomEdgeExec) Exec(ctx context.Context) (*RoomEdge, error) {
	var v RoomEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RoomEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RoomEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance RoomEdgeExecArray) Exec(ctx context.Context) ([]RoomEdge, error) {
	var v []RoomEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RoomEdgeFields = []string{"cursor"}

type RoomEdge struct {
	Node   Room   `json:"node"`
	Cursor string `json:"cursor"`
}

type MessagePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance MessagePreviousValuesExec) Exec(ctx context.Context) (*MessagePreviousValues, error) {
	var v MessagePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MessagePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MessagePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance MessagePreviousValuesExecArray) Exec(ctx context.Context) ([]MessagePreviousValues, error) {
	var v []MessagePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MessagePreviousValuesFields = []string{"id", "user", "roomid", "content"}

type MessagePreviousValues struct {
	ID      string `json:"id"`
	User    string `json:"user"`
	Roomid  string `json:"roomid"`
	Content string `json:"content"`
}

type MessageSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *MessageSubscriptionPayloadExec) Node() *MessageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Message"},
		"node",
		[]string{"id", "user", "roomid", "content"})

	return &MessageExec{ret}
}

func (instance *MessageSubscriptionPayloadExec) PreviousValues() *MessagePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MessagePreviousValues"},
		"previousValues",
		[]string{"id", "user", "roomid", "content"})

	return &MessagePreviousValuesExec{ret}
}

func (instance MessageSubscriptionPayloadExec) Exec(ctx context.Context) (*MessageSubscriptionPayload, error) {
	var v MessageSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MessageSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MessageSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance MessageSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]MessageSubscriptionPayload, error) {
	var v []MessageSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MessageSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type MessageSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Message     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type MessageExec struct {
	exec *prisma.Exec
}

func (instance MessageExec) Exec(ctx context.Context) (*Message, error) {
	var v Message
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MessageExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MessageExecArray struct {
	exec *prisma.Exec
}

func (instance MessageExecArray) Exec(ctx context.Context) ([]Message, error) {
	var v []Message
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MessageFields = []string{"id", "user", "roomid", "content"}

type Message struct {
	ID      string `json:"id"`
	User    string `json:"user"`
	Roomid  string `json:"roomid"`
	Content string `json:"content"`
}

type MessageEdgeExec struct {
	exec *prisma.Exec
}

func (instance *MessageEdgeExec) Node() *MessageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Message"},
		"node",
		[]string{"id", "user", "roomid", "content"})

	return &MessageExec{ret}
}

func (instance MessageEdgeExec) Exec(ctx context.Context) (*MessageEdge, error) {
	var v MessageEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MessageEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MessageEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance MessageEdgeExecArray) Exec(ctx context.Context) ([]MessageEdge, error) {
	var v []MessageEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MessageEdgeFields = []string{"cursor"}

type MessageEdge struct {
	Node   Message `json:"node"`
	Cursor string  `json:"cursor"`
}

type RoomConnectionExec struct {
	exec *prisma.Exec
}

func (instance *RoomConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *RoomConnectionExec) Edges() *RoomEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"RoomWhereInput", "RoomOrderByInput", "RoomEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Room"},
		"node",
		RoomFields)

	return &RoomEdgeExecArray{nodes}
}

func (instance *RoomConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateRoom"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance RoomConnectionExec) Exec(ctx context.Context) (*RoomConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &RoomConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance RoomConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RoomConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance RoomConnectionExecArray) Exec(ctx context.Context) ([]RoomConnection, error) {
	var v []RoomConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RoomConnectionFields = []string{}

type RoomConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []RoomEdge `json:"edges"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "userName", "alias", "passWord", "email", "ava"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserEdgeFields = []string{"cursor"}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "userName", "alias", "passWord", "email", "ava"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "userName", "alias", "passWord", "email", "ava"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}
